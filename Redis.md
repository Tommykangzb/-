# Redis

Redis的常见数据类型：

常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。

### Redis的特性：

多样的数据类型，持久化，集群，事务

### Redis的一些基本命令

select命令进行数据库的切换；查看当前的key值：key* ；  清除当前数据库 ：flushdb;  清除全部数据库：flushall ;  exists key :判断key是否存在；  move key 1 ：移除当前key；  expire key ttl：设置key的过期时间单位是秒；  ttl key：查看当前key的剩余时间

setex key seconds value： 如果key存在就设置seconds过期时间，值为value

setnx key value ：如果key不存在就创建可以，否则就创建失败

#### Redis事务的本质：

一组命令的集合，一个事务的所有命令都会被序列化，在事务的执行过程中会按照顺序执行。一次性，顺序性，排他性地执行一系列的命令。 Redis的单条命令保持原子性，但是事务保证原子性; 

Redis 通过watch实现乐观锁

#### Jedis与lettuce的区别（在SpringBoot2.x之后，使用lettuce替代了Jedis）：

Jedis采用的直连，多个线程操作的话，是不安全的，如果想避免不安全的，使用jedis链接池

Lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的问题，减少了线程数量

#### Redis事务的“编译类型”错误与“运行时错误”的差异：

前者会都不执行并报错，后者则会执行正确的命令；

### Redis为什么是单线程？(处理网络请求的时候只有一个线程来处理)并且还很快？

Redis是很快的，redis是基于内存操作的，CPU不是Redis的瓶颈，它的瓶颈在于服务器的内存和网络带宽。

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### Redis内存达到上限后的处理策略：

volatile-lru: 只对设置了过期时间的key进行LRU删除（默认值）

allkeys-lru：直接从所有的键进行LRU删除

volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐

volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键

volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键

allkeys-lfu：从所有键中驱逐使用频率最少的键

noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键

### Redis持久化

#### RDB

rdb保存的文件是dump.rdb; 触发rdb的机制：1. sava的规则满足的情况下，会自动触发rdb规则  2.执行flushall命令，也会触发rdb规则  3 .推出redis，也会触发rdb规则 

rdb文件的使用： 只需要将rdb文件放在redis启动目录下即可，redis启动时会自动检查dump.rdb文件

**优点**：1.适合大规模的数据恢复  2.对数据的完整性要求不高

**缺点**：1.需要一定的时间间隔进行操作！如果redis意外宕机了，数据就会丢失！ 2.fork进程的时候，会占用一定的内容空间。

#### AOF（Append Only File）

将所有的写命令都记录下来，恢复的时候就把这个文件的全部命令全部执行一遍。秩序追加文件不许改写文件

如果aof文件有错误，这个时候redis时启动不起来的，需要修复这个aof文件，可以使用工具 redis-check-aof --fix来进行修复

优点： 1.每一次修改都会同步，文件的完整性会更加好  2.每秒同步一次，可能会丢失一秒的数据  

缺点： 1. 相对于数据文件来说，aof文件远远大于rdb，修复的速度也会比rdb慢  2.aof的运行效率也要比rdb慢



#### 扩展：

在主从复制中，一般rdb是用来做备用的，放在从机上，不占主机的内存。

如果同时开启两种持久化方式，redis重启的时候会优先载入aof文件来恢复原始的数据，因为通常情况下，aof保存的数据会比rdb更完整

#### 主从复制：

是指将一台redis服务器的数据，复制到其他的redis服务器。数据的复制时单向的，只能是由主节点到从节点。master一写为主，slave以读为主

##### 主从复制的作用：

1. 数据冗余 ： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式
2. 故障恢复：当主节点出现问题时，可以从节点提供服务，实现快速的故障恢复
3. 负载均衡：在主从复制的基础上，配合读写分离，主节点负责写，从节点负责读，分担服务器的负载
4. 高可用（集群）基石：主从复制还是哨兵喝集群能够实现的基础

##### 主从复制的原理：

​	slave启动成功来连接到master后会发送一个sync同步命令； master接收到命令后，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完后，master将传送整个数据文件到slave，并完成一次完全同步。

##### 哨兵模式： 

哨兵是一个独立的进程，独立运行。其原理是哨兵通过发送命令，等待redis服务器响应，从而监控多个redis实例。

##### 多哨兵模式：

假设主服务器宕机，哨兵1先检测到这个结果，系统不会马上进行failove过程，仅仅是哨兵1主观认为主服务器不可用，这个现象称为主观下线。当后面的哨兵也检查到主服务器不可用的时候，并且数量达到阈值，哨兵就会举行一次投票，进行failover故障操作。切换成功后，就会通过发布订阅者模式，让各个哨兵把自己监控的服务器实现切换，这个过程就是客观下线。

当主机从崩溃就恢复时，只能归并到新的主机下，当作从机。

##### 哨兵模式的优点：

1. 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有。
2. 主从可以切换，故障可以转移，系统的可用性更好
3. 哨兵模式就是主从模式ide升级，手动到自动，更加健壮

##### 缺点：

1. redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦
2. 实现哨兵模式的配置十分麻烦，里面选择很多

#### redis缓存穿透和雪崩：

##### 缓存穿透

用户想查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于时向持久层数据库查询。发现也没有，于时本串查询失败。当用户很多的时候，缓存都没有名字，于时都去请求持久层数据库，这会给持久层数据库造成很大的压力，这就相当于出现了缓存穿透

解决方案：

布隆过滤器：一种特殊的数据结构，对所有的可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。

缓存空对象： 当存储层没有命中后，即使返回的空对象也给缓存起来，同时设置一个国企时间，之后再访问这个数据会从缓存中获取，保护了后端数据源

问题：可能会存储很多空值，就会存储很多键浪费空间

##### 缓存击穿

缓存击穿是指一个key非常热点，再不停的扛着高并发，大并发地对一个点进行访问，当这个key失效地瞬间，持续地大并发就穿破缓存，直接请求数据库。当某个key国企地瞬间，有大量地请求并发访问，这类数据一般时热点数据，由于缓存过期，会同时访问数据库来查询最新的数据，并且回写缓存，会使数据库瞬间压力过大

解决方案：设置热点数据永不过期；  加互斥锁：使用发呢不是锁，保证对于么个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。

##### 缓存雪崩

是指再某一个时间段，缓存集中过期失效或者redis宕机。例如：在12点的时候，一波商品全部都放入了缓存，缓存时间为一个小时，但是i到了一点的时候，这批商品的缓存就会消失，二这个时候再对这批商品查询的访问查询，都落到了数据上，对于数据库而言，就会产生周期性的压力波峰，所有的请求都会落到存储层，存储层的调用量就会暴增，造成存储层挂掉。

解决办法：多增几；台服务器；限流降级，加锁排队；  设置不同的过期时间

